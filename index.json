[
  {
    "authors": null,
    "categories": [],
    "content": "",
    "date": 1541827176,
    "expirydate": -62135596800,
    "kind": "page",
    "lang": "en",
    "lastmod": 1541827176,
    "objectID": "93240b7642fb3fa64ff6b4e3117f4ee3",
    "permalink": "https://ritik99.github.io/project/image-panaroma/",
    "publishdate": "2018-11-10T10:49:36+05:30",
    "relpermalink": "/project/image-panaroma/",
    "section": "project",
    "summary": "",
    "tags": [],
    "title": "Image Panaroma",
    "type": "project"
  },
  {
    "authors": null,
    "categories": [],
    "content": "",
    "date": 1541827128,
    "expirydate": -62135596800,
    "kind": "page",
    "lang": "en",
    "lastmod": 1541827128,
    "objectID": "acbb927ca8afcd8068457e28bb9f01d0",
    "permalink": "https://ritik99.github.io/project/denoising-images/",
    "publishdate": "2018-11-10T10:48:48+05:30",
    "relpermalink": "/project/denoising-images/",
    "section": "project",
    "summary": "",
    "tags": [],
    "title": "Denoising Images",
    "type": "project"
  },
  {
    "authors": null,
    "categories": [],
    "content": "",
    "date": 1541827097,
    "expirydate": -62135596800,
    "kind": "page",
    "lang": "en",
    "lastmod": 1541827097,
    "objectID": "41473f556e56505406e610aceeea9449",
    "permalink": "https://ritik99.github.io/project/eigenfaces/",
    "publishdate": "2018-11-10T10:48:17+05:30",
    "relpermalink": "/project/eigenfaces/",
    "section": "project",
    "summary": "",
    "tags": [],
    "title": "Eigenfaces",
    "type": "project"
  },
  {
    "authors": null,
    "categories": [],
    "content": "",
    "date": 1541827064,
    "expirydate": -62135596800,
    "kind": "page",
    "lang": "en",
    "lastmod": 1541827064,
    "objectID": "219d4e2f860b61de9c79c2a293aa44a4",
    "permalink": "https://ritik99.github.io/project/insult-detection/",
    "publishdate": "2018-11-10T10:47:44+05:30",
    "relpermalink": "/project/insult-detection/",
    "section": "project",
    "summary": "",
    "tags": [],
    "title": "Insult Detection",
    "type": "project"
  },
  {
    "authors": null,
    "categories": [],
    "content": "Natural Language Generation (NLG) is characterised as \u0026ldquo;the sub-field of artificial intelligence and computational linguistics that is concerned with the construction of computer systems that can produce understandable tests in English or other human languages from some underlying non-linguistic representation of information\u0026rdquo; (Reiter \u0026amp; Dale, 1997). NLG is one of the earliest topics that researchers started taking interest in.\nFollowing are the most frequent applications of NLG systems:\n Content determination: Determining what kind of information to include while preparing a document Text structuring: Determining the sequence in which information is supposed to appear Sentence aggregation: Deciding information which should be displayed together Lexicalisation: Finding the right words and phrases to express information Referring expression generation: Selecting the words and phrases to identify domain objects Linguistic realisation: Combining all words and phrases into well-formed sentences  All of these topics are fairly complex, and most applications usually involve a combination or all of the above mentioned areas.\nSo, in this blogpost I\u0026rsquo;ll be talking about generating puns using Natural Language Generation which involves some parts of all the above stated applications.\nGenerating puns falls under the field known as computational humor, which is a branch of computational linguistics focused on humor research (there have also been dedicated conferences for this field!).\nFor those of you who don\u0026rsquo;t know what puns are, here are a few punny ones-\nI was going to make myself a belt made out of watches, but then I realized it would be a waist of time.\nWhat do you get when you cross a murderer with a breakfast food? A cereal killer.\nAs illustrated in the above examples, making puns involves using the fact that there are different meanings for a given word or that there are words that sound similar but hold different meanings.\nWhile currently there are a couple of innovative and more truly \u0026ldquo;natural\u0026rdquo; methods for generating puns, the most basic and popular method for generating sentences (and puns) is using a template approach, in which the main context of the sentence is set, while the fillers are derived by the generation model being used. For example, a template might be of the following form: \u0026ldquo;The population of the [country] is [number]\u0026ldquo;, where [country] and [number] are filled in by the model at the run-time. It seems tedious and a little less galmorous, but a large part of the amazing results we see or hear are based on such rule-based methods.\nOne of the most popular models developed in this field is JAPE (Joke Analysis and Production Engine). JAPE is designed to output question-and-answer type puns from a general lexicon. While seemingly easy at first, the model gets fairly complex, with a number of rules being used for coming up with a valid question and sound answer. An example output of this program is:\nQ. What do you call a cry that has pixels? A. A computer scream\nThe original paper on this model by Kim Binsted and Graeme Ritchie can be found here.\nFor the sake of this post, I will be only considering the case of being able to generate words that sound similar to the an input sentence, while still making sure that the sentence makes sense. This is the most basic method, and can be built upon to make more complex mechanisms.\nThe actual idea is pretty simple and the code is similar to the one used by Max Schwartz for his talk at PyGotham 2017, which I\u0026rsquo;ve linked below. I take in a sentence as an input, and barring the stop words, for every other word, I look through a list for words with similar pronounciation and the same POS tag, and then replace it with the best fit. Only those words are considered whose edit distance from the word that is being replaced is below a threshold. Varying this threshold changes how similar the new sentence sounds to the old one.\nThe next step was to generate a list containing the pronounciation and the most likely POS tag for each word in our dictionary. This was done using ARPABET, which is a pronouncing dictionary managed by CMU. Storing the POS tag helps in picking up words that similar sounding to the word we try to replace.\nAnd that is pretty much it. With a few lines of code, I was happy with the results I was getting. An example:\nInput: I am a serial killer.\nOutput: I am a cereal tiller.\nThe implementation was pretty simple, and hence the output is, for most of the time, not that great. Of course, increasing the complexity can increase the kind of outputs we get.\nThe iPython notebook accompanying this post can be found here.\nReferences:\n Building a \u0026ldquo;Pun Generator\u0026rdquo; in Python - https://www.youtube.com/watch?v=6gJKxe5zPXM PyGotham Talks - https://github.com/M0nica/PyGotham-2017-Talks An implementation - https://github.com/maxwell-schwartz/PUNchlineGenerator Computational Humor Seminar - https://www.cse.iitb.ac.in/~vipulsingh10/me/ComputationalHumourSeminar.pdf  ",
    "date": 1541826154,
    "expirydate": -62135596800,
    "kind": "page",
    "lang": "en",
    "lastmod": 1541826154,
    "objectID": "36f14950d131e58915ef954a1b14eef8",
    "permalink": "https://ritik99.github.io/post/nlg/",
    "publishdate": "2018-11-10T10:32:34+05:30",
    "relpermalink": "/post/nlg/",
    "section": "post",
    "summary": "Natural Language Generation (NLG) is characterised as \u0026ldquo;the sub-field of artificial intelligence and computational linguistics that is concerned with the construction of computer systems that can produce understandable tests in English or other human languages from some underlying non-linguistic representation of information\u0026rdquo; (Reiter \u0026amp; Dale, 1997). NLG is one of the earliest topics that researchers started taking interest in.\nFollowing are the most frequent applications of NLG systems:\n Content determination: Determining what kind of information to include while preparing a document Text structuring: Determining the sequence in which information is supposed to appear Sentence aggregation: Deciding information which should be displayed together Lexicalisation: Finding the right words and phrases to express information Referring expression generation: Selecting the words and phrases to identify domain objects Linguistic realisation: Combining all words and phrases into well-formed sentences  All of these topics are fairly complex, and most applications usually involve a combination or all of the above mentioned areas.",
    "tags": [],
    "title": "Natural Language Generation - Generating Puns",
    "type": "post"
  }
]